PROC GLOBAL

  FILE   piffile;                       { data entry PFF file for the application }
  FILE   justone;                       { file handler to make sure that there are no concurrent sessions }
  FILE   TrackUpg;                      { file handler to track upgrades coming from CSWeb server }
  numeric debug = 1;
  numeric training = 1;                 { flag to indicate training mode !!}
  string  TheCommand, newupgrades;
  string  CSPro;                         { CSPro executables directory }
  string  AppName;                       { application name }
  string  opid;                          { operator ID }
  string  wrkprj, wrkpii, data, superv, xdir, pictures;      { directories }
  string  backup;                        { SD card for backup }
  string  temp;                        { directory where data collected by supervisor (acting as interviewer) is transferred to his/her machine }
  string  btsup, btwork, btsamp;           { directories used by the client/server applications to send/receive data via bluetooth }
  string  fpath, fname, work, dicts, entry, utility, wrkref, upgrades, SampData, SampApps, images, receive, pilotdata, audiodata, quizdata;
  string     fnameHH, fnameIN;              { to extract file name from HOUSEHOLD and INDIVIDUAL dictionaries }
  string  quest;
  string  chkfile;
  string  heading;
  string  xparaux;
  string  xparamet;                        { parameter to be passed to the data collection applications }
  string ccode;                            { country code for dictionaries }
  string pcode;                            { phase code for dictionaries }
  string btserver = "";

  alpha(4)   xintnum;                      { Interviewer }
  alpha(4)   xsuperv;                      { Supervisor }
  alpha(8)   xfilenum;                     { Number corresponding to data file names }
  alpha(4)   xcluster;                     { Cluster number }
  alpha(2)   xteam ;                     { team number }
  string     xcase;                        { Case: Cluster number, HOUSEHOLD number, line woman/man number }
  string     upgrname;                     { names for the upgrades coming from supervisor machine }
  string     IntName, SupName;              { interviewer and supervisor names }
  string     xlang;                        { to check if there is another session running }
  string versiontxt ; // text showing version information at top of menu
  string sysver;                           // number of last upgrade
  string clustfname;                      { keeps clusters filename after dictionary closed }

  numeric i, x, ifok, action, option, partial, IntCode, IntSex, IntRole, setalready;
  numeric j, k, xlen, totintvw, steam, n, SameSession, HHprevious;
  numeric PrevUpgrade = 0, NewUpgrade = 0;
  numeric isAndroid ;                        // !! boolean to store OS
  numeric useCSBT = 0;                          // !! flag to select use of CSPro built-in bluetooth 
  list string listupgrades;
  list string dirstocheck;  

  array interview(20);                     { to store interviewers assigned to a supervisor }
  array interrole(20);                     { role of interviewers assigned to a supervisor }
  array string intername(20);              { interviewer's name assigned to supervisor }
  valueset fieldworkers, m_fieldworkers, f_fieldworkers;
  valueset codes;
  
  array intvwcode(400);                    { to store interviewers - code }
  array intvwrole(400);                    {                       - role }
  array intvwteam(400);                    {                       - team }
  array intvwsex(400);                     {                       - sex  }
  array string intvwname(400);              {                       - name }

  array string caselist ( 100, 7 );

  { setup basic user bar }
  function userbase();
    userbar( clear );
    userbar( add button, "<",    do("PreviousField") );
    userbar( add button, ">",    do("NextField") );
    userbar( add button, ">>|",  do("AdvanceToEnd") );
    userbar( add button, "Lang", do("ChangeLanguage") );
    userbar( add button, "Ver",  Getversion() );
  end;

  { set value sets based on language }
  function OnChangeLanguage()
    setvaluesets( "_" + getlanguage() );
    savesetting("Language", getlanguage());
  end;

  { launches CSEntry stopping DCMenu }
  function runpffS();
    ExecPff( AppName + ".pff", maximized, stop );
  end;

  { launches CSEntry with DCMenu waiting in the background }
  function runpffW();
    ExecPff( AppName + ".pff", maximized, wait );
  end;

  { function used to launch CSIndex }
  function RunIndex();
    { Using single quotes instead of double quotes as double quotes are needed in the string generated }
    TheCommand = '"' + cspro + '\CSIndex.exe" ' + entry + "\" + AppName + '.pff';
    ExecSystem( TheCommand, maximized, wait );
  end;


  { check if a file exist and deletes it }
  function fdel( string thisfile )
    if FileExist( thisfile ) then
      FileDelete( thisfile )
    endif;
  end;

  { check and create folder if it doesn't exist }
  function ChkDir( string thisfile )
    if !DirExist( thisfile ) then
      DirCreate(thisfile);
    endif;
  end;

  { since all applications are of data entry type the first lines are the same for all of them }
  function InitPFF()
    setfile( piffile, entry + "\" + AppName + ".pff", create );
    FileWrite( piffile, "[Run Information]" );
    FileWrite( piffile, "Version=CSPro 7.2" );
    FileWrite( piffile, "AppType=Entry" );
    FileWrite( piffile, "[DataEntryInit]" );
    FileWrite( piffile, "OperatorID=" + xintnum );
  end;

  { prepares PIF file for HOUSEHOLDs or INDIVIDUAL data collection }
  function genpff( addmode, questype, savpart, revisit, change, hghtwght )
    InitPff();

    if addmode then
      FileWrite( piffile, "StartMode=ADD;" + xcase );
      FileWrite( piffile, "Lock=Add" );
    else
      FileWrite( piffile, "Lock=Add" );
      if savpart = 1 then
        FileWrite( piffile, "StartMode=ADD;" + xcase );
      else
        FileWrite( piffile, "StartMode=MODIFY;" + xcase );
      endif;
    endif;
    FileWrite( piffile, "ShowInApplicationListing=Never" );
    FileWrite( piffile, "Fullscreen=YES" );
//    FileWrite( piffile, "AutoAdd=No" );       
    FileWrite( piffile, "NoFileOpen=NO" );
    FileWrite( piffile, "Interactive=OFF" );

    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, "Application=" + entry + "\" + AppName + ".ent" );
    if questype = 1 then
      FileWrite( piffile, "InputData=" + data + "\H" + xfilenum + ".DAT" );
      FileWrite( piffile, "Paradata="  + data + "\H" + xfilenum + ".cslog" );
      FileWrite( piffile, "Listing="   + data + "\H" + xfilenum + ".lst" );
    else
      FileWrite( piffile, "InputData=" + data + "\I" + xfilenum + ".DAT" );
      FileWrite( piffile, "Paradata="  + data + "\I" + xfilenum + ".cslog" );
      FileWrite( piffile, "Listing="   + data + "\I" + xfilenum + ".lst" );
    endif;

    FileWrite( piffile, "[ExternalFiles]" );
    if questype = 1 then
      FileWrite( piffile, ccode + "IN" + pcode + "="   + data   + "\I" + xfilenum + ".DAT" );
      FileWrite( piffile, "HHFORINT=" + work   + "\S" + xcluster + ".csdb" );
      FileWrite( piffile, "INTERV=" + wrkref + "\Interv.csdb" );
    elseif questype = 2 then
      FileWrite( piffile, "CG" + "HH" + pcode + "="   + work   + "\ALLHH.DAT" );
    endif;
    FileWrite( piffile, "CLUSTERS=" + wrkref   + "\CLUSTERS.csdb" );
    FileWrite( piffile, "OTHERS="   + data     + "\O" + xfilenum + ".DAT" );

    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "Language=" + GetLanguage() );
    { customize parameters for different types of data entry modes }
    xparamet[10:1] = edit( "9", revisit );   { if this is a revisit }
    xparamet[11:1] = edit( "9", change );    { to run modify mode }
    xparamet[12:1] = edit( "9", savpart );   { case saved partially }
    xparamet[13:1] = edit( "9", hghtwght );  { to enter height and weight }
    FileWrite( piffile, "Parameter=" + xparamet + xcluster + xteam );
    FileWrite( piffile, "Pictures=" + pictures); // for use with camera app !!!
    FileWrite( piffile, "OnExit=.\DCMenu.pff" );
    close( piffile );
  end;

  { check a version available for the next bac-up.  It is a Round-robin system made of up to 10 versions  }
  function backupn()
    do n = 0 while n <= 9 & FileExist( backup + "\C" + xcluster + "_" + edit("9",n) + ".zip" )
    enddo;
    { open space for next back-up }
    x = n + 1;
    if n = 9 then x = 0 endif;
    fname = backup + "\C" + xcluster + "_" + edit("9",x) + ".zip";
    if FileExist(fname) then
      FileDelete( fname );
    endif;
    backupn = n;
  end;

  { finds the drive letter where the flash memory is located }
  function searchdrive()
    numeric found = 0;
    do i = 1 while i <= 5 & !found
      backup = "DEFGH"[i:1] + ":\DATA";
      if DirExist( backup ) then
        found = 1;
      endif;
    enddo;
    searchdrive = found;
  end;

  { makes a backup as soon after leaving the data collection application }
  { copies HOUSEHOLDs, INDIVIDUAL and others }
  function backupf()
    set trace(on);
    numeric nextbkp;
    { eliminates files not required }
    FileDelete( data + "\?" + xfilenum + ".dat.lst" );
    FileDelete( data + "\?" + xfilenum + ".dat.log" );
    {ANDROID}
    if !isAndroid then
      if !searchdrive() | !DirExist( backup ) then
        // errmsg( 070, backup );
        searchdrive();
      endif;
    endif;
    if DirExist( backup ) then
        { handle round robin back-up number }
        nextbkp = backupn();
      if isAndroid then
          compress(backup  + "\C" + xcluster + "_" + edit("9",nextbkp) + ".zip", data +  "\*" + xfilenum + ".DAT");
      else
          TheCommand = Utility + "\UpgradePc\7za.exe a -w" + work + " -i!" + data +  "\*" + xfilenum + ".dat -pDHS" + xintnum  + " " +
          backup  + "\C" + xcluster + "_" + edit("9",nextbkp) + ".zip";
          ExecSystem( TheCommand, maximized, wait );
      endif;
      // errmsg( 072, backup );
    else
      // errmsg( 071, backup );
    endif;
  end;
  { this function will be used when the supervisor collects data to move }
  { it from data directory to receive directory in the same machine      }
  function transuper()
        FileDelete( data + "\?" + xfilenum + ".dat.csidx" ); 
        FileDelete( data + "\?" + xfilenum + ".dat.lst" );
        FileDelete( data + "\?" + xfilenum + ".dat.log" ); 
        FileCopy( data + "\?" + xfilenum + "*.*",     receive );
  end;


  { function used to run and execute the data entry applications }
  function csrun( addmode, questype, savpart, revisit, change, hghtwght )
  {
    Parameters - addmode,  the start mode of a data entry program
                 questype, 1-HOUSEHOLD, 2-INDIVIDUAL (women/men)
                 savpart,  if the case was partially saved (1-partial add, 2-partial modify)
                 revisit,  if it is a revisit to an incomplete interview (result code <> 1)
                 change,   advance to the first field after the control of visits
                 hghtwght, instructs to advance to height/weight section for the HOUSEHOLD
  }
    genpff( addmode, questype, savpart, revisit, change, hghtwght );
    SaveSetting( "DCSession", "2" );
    close( HHFORINT );
    runpffS();
  end;

  { change file setting for HOUSEHOLD assignment for a cluster }
  function SetEligFile(newfile = 0)
    x = 1;
    { file name for HOUSEHOLDs assigned to interviewers is only known after the cluster is entered. It is set here }
    fname = work + "\eligibles.csdb";
    if !FileExist( fname ) then
      errmsg( 035, fname );
      x = 0;
    else
      if newfile & !setfile( ELIGINDV, fname, create ) | 
        !newfile & !setfile( ELIGINDV, fname, update ) then
        errmsg( 035, fname );
        x = 0;
      endif;
    endif;
    SetEligFile = x;
  end;
  
  { runs wrkelig logic  }
  function WrkElig( xtype, xhhnum = notappl, xintsex = notappl )
    SetEligFile(1);
    { type   1-HOUSEHOLDs, 2-INDIVIDUAL, 3: HOUSEHOLDs not including shared }
    alpha(10)  key_HH;                     { !! adjust to the length of the key cluster+hh+line }
    
    fnameHH = work + "\ALLHH.DAT";
    fnameIN = data + "\I" + xfilenum + ".DAT";

    // check if hh file and INDIVIDUAL file exists and create empty file if necessary to avoid error message
    if FileExist(fnameHH) then
      setfile(CGHH80, fnameHH, update);
    else
      setfile(CGHH80, fnameHH, create);
    endif;
    if xtype = 2 then
      if FileExist(fnameIN) then
        setfile(CGIN80, fnameIN, update);
      else
        setfile(CGIN80, fnameIN, create);
      endif;
    endif;
    while loadcase( CGHH80 ) do
      { HOUSEHOLDs requested }
      if xtype in 1,3 then
        key_HH = edit("9999",QHCLUST) + edit("9999",QHNUMBER) + "  ";
        if loadcase( ELIGINDV, key_HH) then
          delcase( ELIGINDV );
        endif;
        ZCLUSTER = QHCLUST;
        ZNUMBER  = QHNUMBER;
        ZLINE    = notappl;
        ZNAME    = " ";
        ZQTYPEA  = " ";
        ZRESULT  = NaToZero(QHRESULT);
        ZOWNER   = QHINTNUM;
        ZMALE    = QHELIGM;
        if soccurs( CGHH80.QHSEC01X ) then
          ZNAME = strip(QHFIRSTN(1)) + " " + strip(QHLASTN(1));
        endif;
        ZADDRESS = QHADDRESS;
        if length( strip(ZNAME) ) = 0 then ZNAME = ZADDRESS endif;
        if QHRESULT <> 1 then
          // ZSTATUS  = tr("Incomplete") + maketext(" (%1d)", QHRESULT);
          ZSTATUS  = getlabel(QHRESULT, QHRESULT);
          ZSTATUSC = 2;
        elseif partialcs( 1, QHCLUST, QHNUMBER, 0, fnameHH  ) then
          ZSTATUS  = tr("Partial");
          ZSTATUSC = 3;
        else
          ZSTATUS  = tr("Complete");
          ZSTATUSC = 1;
        endif;
        ZQUEST  = 1;
        // flag if hh has delegated individuals
        ZDELEG = count(QHSEC01 where QHDELEG > 0);
        writecase( ELIGINDV );
              
      { INDIVIDUALs requested }
      elseif xhhnum = QHNUMBER | xhhnum = 0 then
        ZADDRESS = QHADDRESS;
        if {!length(strip(QHADDRESS)) & }soccurs( CGHH80.QHSEC01X ) then
          ZADDRESS = strip(QHFIRSTN(1)) + " " + strip(QHLASTN(1));
        endif;
        for i in record QHSEC01 do
        { eligible INDIVIDUALs according to interviewer's sex.  3 is used by supervisor menu as they can see both INDIVIDUALs }
        { training flag set to 1 allows any gender to do any interview  }
         if QH09 & xintsex = 2 | QH10 & xintsex = 1 | ( QH09 | QH10 ) & ( xintsex = 3 | training ) then
          // if QH09 | QH10 then    
            if QH09 then
              key_HH = edit("9999",QHCLUST) + edit("9999",QHNUMBER) + edit("99",QH09);
            else
              key_HH = edit("9999",QHCLUST) + edit("9999",QHNUMBER) + edit("99",QH10);
            endif;
            if loadcase( ELIGINDV, key_HH ) then
              delcase( ELIGINDV );
            endif;
            ZCLUSTER = QHCLUST;
            ZNUMBER  = QHNUMBER;
            if QH09 then
              ZLINE  = QH09;
              ZQTYPEA  = tr("Female");
            else
              ZLINE  = QH10;
              ZQTYPEA  = tr("Male");
            endif;
            ZNAME    = QH02;
            ZQUEST   = 2;
            ZOWNER   = QHINTNUM;
            ZSTATUS  = tr("Not Visited");
            ZSTATUSC = 0;
            if loadcase( CGIN80, key_HH) then
              ZOWNER   = QINTNUM;
              ZRESULT  = NaToZero( QRESULT );
              if QRESULT <> 1 then
                ZSTATUS  = getlabel(QRESULT, QRESULT);
                ZSTATUSC = 2;
              elseif partialcs( 2, QCLUSTER, QNUMBER, QLINE, fnameIN  ) then
                ZSTATUS  = tr("Partial");
                ZSTATUSC = 3;
              else
                ZSTATUS  = tr("Complete");
                ZSTATUSC = 1;
              endif;
              ZOWNER  = QINTNUM;
            endif;
            ZDELEG = QHDELEG(i);
            // if ZOWNER = WINTNUM & ZDELEG then // if delegated and is on the owner device adjust status flag 
            //   ZSTATUSC = 7;
            //   ZSTATUS = getlabel(ZSTATUS, ZSTATUS);
            // endif;
            writecase( ELIGINDV );
          endif;
        enddo;
        if xhhnum then
          break;
        endif;
      endif;
    enddo;
    close( CGHH80 );
    close( CGIN80 );
    // check HHFORINT / Sxxxx file in case there are HOUSEHOLDs assigned but not begun yet
    // also check consistency of assignments versus actual data on interviewer device
    // hh assigned to another but found on device 
    // 
    if xtype = 3 then
      forcase HHFORINT do 
        ZCLUSTER = WCLUSTER;
        ZNUMBER  = VNUMBER;
        if VINTCODE = IntCode then // assigned to current interviewer
          ZLINE    = notappl;
          if !loadcase(ELIGINDV, ZCLUSTER, ZNUMBER, ZLINE) then // HOUSEHOLD assigned but not yet begun
            ZLINE    = notappl;
            ZQTYPEA  = " ";
            ZRESULT  = 0;
            ZOWNER   = IntCode;
            ZNAME    =  VNAME;
            ZADDRESS = VADDRESS;
            ZMALE    = VMALE;
            ZSTATUS  = tr("Not Visited");
            writecase(ELIGINDV);
            if VRESULT <> 0 then // if assignment file status different display warning message and reset the result code in HHFORINT
              errmsg(98, VNUMBER, VRESULT, tr("Not Visited"));
              VRESULT = ZRESULT;
              writecase(HHFORINT);
            endif;
          else // hh data already on device
            if ZOWNER <> IntCode then // hh data found in shared .\work files, display message and reset assignment to other interviewer
              errmsg(97, ZNUMBER, ZOWNER);
              VINTCODE = ZOWNER;
              writecase(HHFORINT);
            endif; // if found hh data belongs to current interviewer no need to do anything
          endif;
        else                         // HOUSEHOLD assigned to another interviewer but hh data on device and created by current interviewer
          if loadcase(ELIGINDV, ZCLUSTER, ZNUMBER, ZLINE) & ZOWNER = IntCode then 
            if VINTCODE then // display warning message if assigned to another interviewer
              errmsg(99,VNUMBER, VINTCODE);
            endif;
            VINTCODE = ZOWNER;
            writecase(HHFORINT);
          endif;
        endif;
      enddo;
    endif;
    close( ELIGINDV );
  end;

  function fill_caselist (seltype);
    numeric ctr = 0;
    caselist.clear();
    // reads cases from ELIGINDV into a list based on selection criteria
    // list is used to display hh/INDIVIDUAL cases for selection
    // seltype: 0:all hhs assigned to interviewer
    //          1:only completed hhs assigned to interviewer
   //           2:completed hhs assigned to other interviewers
   //           3:all cases - used for selection of INDIVIDUALs
   //           4:biomarkers selection
   //           5:delegation selection
    SetEligFile(0);
    forcase ELIGINDV do
      // do selection first skip if case doesn't meet criteria
      if ( seltype = 0 & ZOWNER = IntCode ) |                      // hh for interviewer
      ( seltype = 1 & ZRESULT = 1 & ZOWNER = IntCode { & ZSTATUSC = 1 }) |           // completed hhs of interviewer, no partials
      ( seltype = 4 & ZRESULT = 1 & ZOWNER = IntCode & ZMALE = 1   ) |           // completed hhs of interviewer, include partials for biomarkers
                                                                                 // !! only hh's selected for male interview eligible for biomarkers !!       
      ( seltype = 2 & ZRESULT = 1 & ZOWNER <> IntCode & ZSTATUSC = 1 & ZDELEG )|          //  completed hh's of other interviewers
        seltype in 3,5                                              //  all cases 
      then 
        inc(ctr);
        // next, populate the array
        if seltype in 0:2,4 then                             // hh's
          caselist(ctr,1) = maketext("%04d", ZNUMBER );
          caselist(ctr,2) = ZNAME;
          caselist(ctr,3) = maketext("%04d", ZOWNER );
          caselist(ctr,4) = ZSTATUS;
          caselist(ctr,5) = tr( "YN" )[ZMALE:1];
        elseif seltype = 3 & WINTNUM in ZOWNER, ZDELEG then                                       // INDIVIDUALs 
          caselist(ctr,1) = maketext("%04d", ZNUMBER );
          caselist(ctr,2) = maketext("%02d", ZLINE );
          caselist(ctr,3) = ZNAME;
          caselist(ctr,4) = maketext("%04d", ZOWNER );
          caselist(ctr,5) = ZQTYPEA;
          caselist(ctr,6) = ZSTATUS;
        elseif seltype = 5 then                                       // delegation
          if ZSTATUSC = 0 | ZDELEG then // delegated or not started 
            caselist(ctr,1) = ZADDRESS;
            caselist(ctr,2) = maketext("%04d", ZNUMBER );
            caselist(ctr,3) = maketext("%02d", ZLINE );
            caselist(ctr,4) = ZNAME;
            caselist(ctr,5) = ZQTYPEA;
            caselist(ctr,6) = ZSTATUS;
            caselist(ctr,7) = maketext("%04d", ZDELEG );
          endif;
        endif;
      endif;
    enddo;
    close(ELIGINDV);
  end;

    { generates the PIF file for the application used to display }
    { fix the result of the HOUSEHOLDs assigned to interviewers  }
    function FixResult()
      InitPff();
      FileWrite( piffile, "StartMode=ADD" );
      FileWrite( piffile, "ShowInApplicationListing=Never" );
      FileWrite( piffile, "Lock=Modify, Verify" );
      FileWrite( piffile, "Fullscreen=Yes" );
      FileWrite( piffile, "NoFileOpen=Yes" );

      { Files section }
      FileWrite( piffile, " " );
      FileWrite( piffile, "[Files]" );
      FileWrite( piffile, "Application=" + entry + "\" + AppName + ".ent" );
      FileWrite( piffile, "Listing="     + entry + "\" + AppName + ".lst" );

      { External Files section }
      FileWrite( piffile, " " );
      FileWrite( piffile, "[ExternalFiles]" );
      FileWrite( piffile, "HHFORINT=" + work + "\S" + edit("9999",WCLUSTER) + ".csdb" );

      { Parameters section }
      FileWrite( piffile, " " );
      FileWrite( piffile, "[Parameters]" );
      FileWrite( piffile, "Language=" + GetLanguage() );
      { parameters are HOUSEHOLD number, whether HOUSEHOLD or INDIVIDUAL questionnaire and interviewer sex }
      FileWrite( piffile, "Parameter=" + edit("9999",IntCode) + edit("9999",VNUMBER) );
      FileWrite( piffile, "ViewListing=Never" );     { Do not show .lst -- will be shown manually }
      FileWrite( piffile, "ViewResults=No" );        { Do not show .wrt -- will be shown manually }
      FileWrite( piffile, "OnExit=.\DCMenu.pff" );
      close( piffile );
    end;

    { generates a list of eligible INDIVIDUALs for INDIVIDUAL questionnaire and eligible  }
    { INDIVIDUALs for height and weight                                                   }
    function ListElig()
      InitPff();
      FileWrite( piffile, "StartMode=ADD" );
      FileWrite( piffile, "ShowInApplicationListing=Never" );
      FileWrite( piffile, "Fullscreen=Yes" );
      FileWrite( piffile, "NoFileOpen=Yes" );

      { Files section }
      FileWrite( piffile, " " );
      FileWrite( piffile, "[Files]" );
      FileWrite( piffile, "Application=" + entry + "\" + AppName + ".ent" );
      FileWrite( piffile, "Listing="     + entry + "\" + AppName + ".lst" );
      FileWrite( piffile, "WriteData=.\" + AppName + ".wrt" );

      { External Files section }
      FileWrite( piffile, " " );
      FileWrite( piffile, "[ExternalFiles]" );
      FileWrite( piffile, ccode + "HH" + pcode + "=" + data + "\H" + xfilenum + ".DAT" );
      FileWrite( piffile, ccode + "IN" + pcode + "=" + data + "\I" + xfilenum + ".DAT" );
      FileWrite( piffile, "CLUSTERS=" + wrkref   + "\CLUSTERS.csdb" );

      FileWrite( piffile, "[Parameters]" );
      { parameters are: cluster and HOUSEHOLD number (may include others for sub-samples) }
      FileWrite( piffile, "Language=" + GetLanguage() );
      FileWrite( piffile, "Parameter=" + xcase );
      FileWrite( piffile, "ViewListing=Never" );
      FileWrite( piffile, "ViewResults=No" );
      FileWrite( piffile, "OnExit=.\DCMenu.pff" );
      close( piffile );
    end;

    { generates a list of all questionnaires collected by an interviewer }
    function LstQuest()
      InitPff();
      FileWrite( piffile, "StartMode=ADD" );
      FileWrite( piffile, "ShowInApplicationListing=Never" );
      FileWrite( piffile, "Fullscreen=Yes" );
      FileWrite( piffile, "NoFileOpen=Yes" );

      { Files section }
      FileWrite( piffile, " " );
      FileWrite( piffile, "[Files]" );
      FileWrite( piffile, "Application=" + entry + "\" + AppName + ".ent" );
      FileWrite( piffile, "Listing="     + entry + "\" + AppName + ".lst" );
      FileWrite( piffile, "WriteData=.\" + AppName + ".wrt" );

      { External Files section }
      FileWrite( piffile, " " );
      FileWrite( piffile, "[ExternalFiles]" );
      FileWrite( piffile, "CG" + "HH" + pcode + "=" + data + "\H" + xfilenum + ".DAT" );
      FileWrite( piffile, ccode + "IN" + pcode + "=" + data + "\I" + xfilenum + ".DAT" );

      FileWrite( piffile, "[Parameters]" );
      FileWrite( piffile, "Language=" + GetLanguage() );
      FileWrite( piffile, "Parameter=" + xcluster );
      FileWrite( piffile, "Interviewer=" + xintnum );
      FileWrite( piffile, "ViewListing=Never" );
      FileWrite( piffile, "ViewResults=No" );
      FileWrite( piffile, "OnExit=.\DCMenu.pff" );
      close( piffile );
    end;

    { generates a list of nottes taken by interviewer in cluster }
    function ListNotes()
      InitPff();
      FileWrite( piffile, "StartMode=ADD" );
      FileWrite( piffile, "ShowInApplicationListing=Never" );
      FileWrite( piffile, "Fullscreen=Yes" );
      FileWrite( piffile, "NoFileOpen=Yes" );

      { Files section }
      FileWrite( piffile, " " );
      FileWrite( piffile, "[Files]" );
      FileWrite( piffile, "Application=" + entry + "\" + AppName + ".ent" );

      { External Files section }
      FileWrite( piffile, " " );
      FileWrite( piffile, "[UserFiles]" );
      FileWrite( piffile, "FILENOTE=" + work + "\ALLNOTES.DAT" );

      FileWrite( piffile, "[Parameters]" );
      { parameters are: cluster and HOUSEHOLD number (may include others for sub-samples) }
      FileWrite( piffile, "Language=" + GetLanguage() );
      FileWrite( piffile, "Parameter=" + xcluster + "0" );
      FileWrite( piffile, "ViewListing=Never" );
      FileWrite( piffile, "ViewResults=No" );
      FileWrite( piffile, "OnExit=.\DCMenu.pff" );
      close( piffile );
    end;

    { function to generate the source and destination of files to transfer }
    function GenFileXML( string sourcedir, alpha(1) prefix, string suffix, string destdir )
      fname = sourcedir + "\" + prefix + xfilenum + suffix;
      FileWrite( piffile, '<file source="' + fname + '" destdir="' + destdir + '" />' );        { actual file name }
    end;
    { transfer data from interviewer to supervisor using bluetooth }
    function transfer()
      if isAndroid | useCSBT then
        { delete files not required }
        FileDelete( data + "\?" + xfilenum + ".dat.csidx" ); 
        FileDelete( data + "\?" + xfilenum + ".dat.lst" );
        FileDelete( data + "\?" + xfilenum + ".dat.log" ); 
        SyncServer( Bluetooth );
      else
        fpath = utility + "\btclientPC";
        setfile( piffile, fpath + "\transfer.xml", create );
        { XML construction for transferring data }
        FileWrite( piffile, '<?xml version="1.0" encoding="utf-8" ?>' );
        FileWrite( piffile, "<transfer>" );
        FileWrite( piffile, "<caption>" + IntName + " " + tr("Sending data to supervisor") + "</caption>" );
        { restrict the client machine to the supervisor machine (WSUPER) }
        FileWrite( piffile, '<to name="' + SupName + '" id="' + edit("9999",WSUPER) + '" />' );
        { encryption key, auto send parameter and timeout in seconds after which polling for devices is terminated }
        FileWrite( piffile, "<key>1111111111111111</key>" );
        FileWrite( piffile, "<autosend>true</autosend>" );
        FileWrite( piffile, "<timeout>120</timeout>" );
        GenFileXML( data, "H", ".dat",       btsup );    { HOUSEHOLDs data file }
        GenFileXML( data, "H", ".dat.sts",   btsup );    { HOUSEHOLDs partial save file }
        GenFileXML( data, "H", ".dat.csnot", btsup );    { HOUSEHOLDs notes file }
        GenFileXML( data, "I", ".dat",       btsup );    { INDIVIDUAL data file }
        GenFileXML( data, "I", ".dat.sts",   btsup );    { INDIVIDUAL partial save file }
        GenFileXML( data, "I", ".dat.csnot", btsup );    { INDIVIDUAL notes file }
        GenFileXML( data, "O", ".dat",       btsup );    { others file }
        { close XML definition }
        FileWrite( piffile, "</transfer>" );
        close( piffile );
        TheCommand = fpath + "\btclientPC.exe ";
        ExecSystem( TheCommand, normal, wait );
      endif;
    end;

    { share HOUSEHOLD data with another interviewer in the same team using bluetooth }
    function sendhhdat()
      if isAndroid | useCSBT then
        x = showarray( "Select whom you want to share HH data with", TeamShare, title("Codes", "Interviewer Names") );  
        btserver = TeamShare(x,1);
        if SyncConnect( Bluetooth, btserver) then
          fname = data + "\H" + xfilenum + ".DAT";
          SyncFile( PUT, fname, btwork );
          SyncDisconnect();
        endif;
      else
        fpath = utility + "\btclientPC";
        setfile( piffile, fpath + "\transfer.xml", create );
        { XML construction for transferring data }
        FileWrite( piffile, '<?xml version="1.0" encoding="utf-8" ?>' );
        FileWrite( piffile, "<transfer>" );
        FileWrite( piffile, "<caption>" + IntName + " " + tr("Sharing HH Data with other interviewers") + "</caption>" );
        { restrict sharing the HOUSEHOLD data to interviewers in the same team }
        { including the supervisor but excluding him/herself                   }
        do i = 1 while interview(i)
          if IntCode <> interview(i) then
            FileWrite( piffile, '<to name="' + intername(i) + '" id="' + edit("9999",interview(i)) + '" />' );
          endif;
        enddo;
        { encryption key, auto send parameter and timeout in seconds after which polling for devices is terminated }
        FileWrite( piffile, "<key>1111111111111111</key>" );
        FileWrite( piffile, "<autosend>true</autosend>" );
        FileWrite( piffile, "<timeout>120</timeout>" );
        GenFileXML( data, "H", ".dat",     btwork );      { HOUSEHOLDs data file }
        GenFileXML( data, "H", ".dat.sts", btwork );      { HOUSEHOLDs partial save file }
        FileWrite( piffile, "</transfer>" );
        close( piffile );
        TheCommand = fpath + "\btclientPC.exe ";
        ExecSystem( TheCommand, normal, wait );
      endif;
    end;

    { make interviewer machine available as server to receive HOUSEHOLD data from other interviewers }
    function receivehh()
      if isAndroid | useCSBT then
        SyncServer( Bluetooth );
      else
        fpath = utility + "\btserverPC";
        TheCommand = fpath + "\btserverPC.exe " + '"id=' + edit("9999",IntCode) + '" "name=' + IntName + '" "rootdir=' + wrkprj + '" "encrkey=1111111111111111"';
        ExecSystem( TheCommand, normal, wait );
      endif;
    end;
    function string getupgradepath (string str_input, string str_match);
      errmsg("str_input=%s",str_input);
      errmsg("str_match=%s",str_match);
      numeric wbegin   = pos(str_match, str_input);
      numeric lenmatch = length(str_match);
      numeric leninput = length(str_input);
      numeric aftermatch = wbegin+lenmatch;
      if wbegin then
        getupgradepath = str_input[aftermatch:leninput-aftermatch+1];
      else
        getupgradepath = "";
      endif;
    end;
    { applying updates coming from IFSS into supervisor's machine in directory upgrades }

     
    function CopyList (string source_dir, string file_filter, string target_dir);
      numeric ctr;
      listupgrades.clear();
      DirList( listupgrades, source_dir, file_filter);
      do ctr = 1 while ctr <= ListUpgrades.length()
        FileCopy( ListUpgrades(ctr), target_dir );      
      enddo;        
    end;
    function string extract_UpgrNum (string str_path)
      string str_fname = path.GetFileName(str_path);
      numeric w_start, w_len;
      // get upgrade number from the file name
      // note this assumes the file name minus extension ends in n digits and there are no other numbers in the name
      // 123456789
      // upgdhs1.zip
      w_start = length(upgrname) + 1;
      w_len   = pos(".zip", str_fname) - w_start;
      extract_UpgrNum = str_fname[w_start:w_len];
    end;
    { applying updates coming from supervisor's machine in directory upgrades }
    {ANDROID - new function for checking and unzipping upgrades}
    function ApplyUpgr()
      numeric cur_version = tonumber(sysver);
      numeric new_version;
      string fmask = upgrname + "*.zip";
      if isAndroid  then
        // use line below with standard upgrade zip structure !!!
        // fpath = PathName(CSEntry)
        fpath = PathName(CSEntry) + "cc81";
      else
        fpath = wrkprj;
      endif;
      // do dir list
      ListUpgrades.clear();
      DirList( ListUpgrades, upgrades, fmask);
      ListUpgrades.sort();
      // loop through files checking if they are new/changed
      if length(ListUpgrades) > 0 then
        do i = 1 while i <= length(ListUpgrades)  
          fname = ListUpgrades(i);
          new_version = tonumber(extract_UpgrNum(fname));
          if  new_version > cur_version then
            ifok = decompress(fname, fpath); 
            if ifok then
              errmsg( 090, path.GetFileName(fname));
              cur_version = new_version;
            else
              errmsg( 092, path.GetFileName(fname));
              FileDelete(fname); // !!! delete the file that can't be extracted in case we need to download another copy
            endif;
          endif;
        enddo;
      endif;
      if cur_version > tonumber(sysver) then
        sysver = edit("999", cur_version);
        SaveSetting( "Version", sysver );
        errmsg(91);
        stop(-1);
      endif;
    end;
    
    { change the file setting for the HOUSEHOLD assignment for a cluster }
    function SetAssignFile()
      x = 1;
      { file name for HOUSEHOLDs assigned to interviewers is only known after the cluster is entered.  It is set here }
      fname = work + "\S" + edit("9999",WCLUSTER) + ".csdb";
      if !FileExist( fname ) then
        errmsg( 095, fname, WCLUSTER );
        x = 0;
      else
        if !setfile( HHFORINT, fname ) then
          errmsg( 095, fname, WCLUSTER );
          x = 0;
        endif;
      endif;
      SetAssignFile = x;
    end;
    function SendFiles ();
        SmartPut(data, "?" + xfilenum + "*.DAT", temp);
        SmartPut(data, "?" + xfilenum + "*.dat", temp);
        SmartPut(data, "?" + xfilenum + "*.cslog", temp);
        SmartPut(data, "?" + xfilenum + "*.csnot", temp);
        SmartPut(data, "?" + xfilenum + "*.dat.sts", temp);
        SmartPut(data, "?" + xfilenum + "*.DAT.sts", temp);
        SmartPut(pictures, pictures + "P" + xcluster + "*.jpg", temp);
        // // send FW interview data files
        // fname = data + "\F*" + edit("9999", WINTNUM) + ".DAT";
        // SyncFile( PUT, fname, receive );
        // // send FW quiz data files
        // fname = data + "\Q*" + edit("9999", WINTNUM) + ".DAT";
        // SyncFile( PUT, fname, receive );
    end;
    { receiving HOUSEHOLD assignment from supervisor }
    function sync_sup()
      close( HHFORINT );
      if isAndroid | useCSBT then
        btserver = edit("9999", WSUPER);
        if SyncConnect( Bluetooth, btserver ) then
          // get the assignment file
          fname = work + "\S" + xcluster + ".csdb";
          FileDelete( fname );
          SyncFile( GET, fname, work );
          // send interview files
          SendFiles();
          // now get any new upgrades 
         // get the latest versions of the application files from the server 
         // not using syncapp until all devices are installed from server
          SyncFile(GET, wrkprj + "/Entry/*.pen", PathName(Application));
          SyncFile(GET, wrkprj + "/Entry/*.fmf", PathName(Application));
          SyncFile(GET, wrkprj + "/Library/*.*", wrkprj + "/Library");
          SyncFile(GET, wrkprj + "/Dicts/*.dcf", wrkprj + "/Dicts");
          SyncFile(GET, wrkref + "/version.txt", wrkref);
          // syncapp();
          // fname = upgrades + "/" + upgrname + "*.zip";
          // SyncFile( GET, fname, upgrades );
          SyncDisconnect();
          // ApplyUpgr();

        endif;        
      else
        fpath = utility + "\btserverPC";
        TheCommand = fpath + "\btserverPC.exe " + '"id=' + edit("9999",IntCode) + '" "name=' + IntName + '" "rootdir=' + wrkprj + '" "encrkey=1111111111111111"';
        ExecSystem( TheCommand, normal, wait );
      endif;
      SetAssignFile();
    end;

    function receiveupgr()
      if isAndroid | useCSBT then
        btserver = edit("9999", WSUPER);
        if SyncConnect( Bluetooth, btserver ) then
          fname = upgrades + "/" + upgrname + "*.zip";
          SyncFile( GET, fname, upgrades );
          SyncDisconnect();
        endif;        
      else
        // create file with list of existing upgrades to supervisor !!
        fname = ".\TrackUpg.txt";
        TrackUpg.Open(fname, create);
        ListUpgrades.clear();
        DirList( ListUpgrades, upgrades, upgrname + "*.zip");
        do numeric ctr = 1 until ctr > length(ListUpgrades)
          FileWrite(TrackUpg, ListUpgrades(ctr));
        enddo;
        TrackUpg.Close();
        // send trackupgr file to supervisor device
        fpath = utility + "\btclientPC";
        setfile( piffile, fpath + "\transfer.xml", create );
        { XML construction for transferring data }
        FileWrite( piffile, '<?xml version="1.0" encoding="utf-8" ?>' );
        FileWrite( piffile, "<transfer>" );
        FileWrite( piffile, "<caption>" + IntName + " " + tr("Sending data to supervisor") + "</caption>" );
        { restrict the client machine to the supervisor machine (WSUPER) }
        FileWrite( piffile, '<to name="' + SupName + '" id="' + edit("9999",WSUPER) + '" />' );
        { encryption key, auto send parameter and timeout in seconds after which polling for devices is terminated }
        FileWrite( piffile, "<key>1111111111111111</key>" );
        FileWrite( piffile, "<autosend>true</autosend>" );
        FileWrite( piffile, "<timeout>120</timeout>" );
        FileWrite( piffile, '<file source="' + fname + '" destdir="' + btwork + '" />' );        { actual file name }
        { close XML definition }
        FileWrite( piffile, "</transfer>" );
        close( piffile );
        TheCommand = fpath + "\btclientPC.exe ";
        ExecSystem( TheCommand, normal, wait );
        fpath = utility + "\btserverPC";
        TheCommand = fpath + "\btserverPC.exe " + '"id=' + edit("9999",IntCode) + '" "name=' + IntName + '" "rootdir=' + wrkprj + '" "encrkey=1111111111111111"';
        ExecSystem( TheCommand, normal, wait );
      endif;
      ApplyUpgr();
    end;

    { gets one HOUSEHOLD from file provided by supervisor with HOUSEHOLDs assigned to interviewers }
    function getonehh( task )
      numeric cancelled, y = 1, newHH;
      fname = work + "\S" + xcluster + ".csdb";
      if !FileExist( fname ) then
        errmsg( 095, fname, WCLUSTER );
        ifok = 0;
      else
        if task = 4 then  { eligible INDIVIDUALs }
          { find if HOUSEHOLD assigned or not to interviewer by supervisor }
          x = accept( tr("Individual interview is from"),
                      tr("Household interviewed by you"),
                      tr("Household interviewed by someone else (shared)"),
                      tr("Cancel") );
        else                    { other options use HOUSEHOLDs assigned to interviewer }
          x = 1;
        endif;
        cancelled = ( task = 1 & x in 0,4 | task = 4 & x in 0,3 );
        ifok = 0;
        if task in 1,2 then // hh int, list eligibles (all assigned hhs)
          fill_caselist(0);
          heading = tr("Select Household");
        elseif task = 3 then // biomarkers - only hhs with result = 1
          fill_caselist(4);
          heading = tr("Select Household for Biomarkers Entry");
        elseif task = 4 then // INDIVIDUALs ( only hhs with result = 1 )
          heading = tr("Select Household for individual interview");
          if x = 1  then // not shared
            fill_caselist(1);
          else // shared
            fill_caselist(2);
          endif;
        elseif task = 5 then    { New HOUSEHOLD not in original sample, ie split HOUSEHOLD }
          SetAssignFile();
          // can only split from a HOUSEHOLD assigned to you !!!
          ifok = selcase( tr("Select the HOUSEHOLD that is to be split and press continue. Otherwise press cancel to return to main menu"), HHFORINT, "", 4) 
            include( VNAME, VADDRESS, VRESULT )
            where VINTCODE = WINTNUM;
          if ifok then
            { Generate a new HOUSEHOLD number based on the interviewer's code, and ensure it does not clash with another }
            newHH = 1000 + VNUMBER;     { !!! make sure to generate a HH number that doesn't exist in the sample }
            do i = 2 while find( HHFORINT, =, edit("9999",newHH) )
              if newHH < 10000 then
                newHH = i * 1000 + VNUMBER;
              else
                newHH = 9000 + i;
              endif;
            enddo;
            VNAME   = maketext("SPLIT FROM (%s-%s)", VNAME, VADDRESS);
            VNUMBER = newHH;
            VRESULT = 0;
            VINTCODE = WINTNUM;
            writecase( HHFORINT );
            errmsg( 045, VNUMBER, VINTCODE );
          endif;
        endif;
        if task <> 5 then
          ifok = showarray(heading, caselist, title ( tr("HH"), tr("Name"), tr("Int."), tr("Status") , tr("Male/LS"))  );
          if y = 1 & !cancelled & !ifok then
            errmsg( 096 );
          else
            SetEligFile(0);
            ZNUMBER = tonumber( caselist(ifok,1) );
            ZLINE = notappl;
            x = loadcase(ELIGINDV, WCLUSTER, ZNUMBER, ZLINE );
            close(ELIGINDV);
          endif;
        endif;
      endif;
      getonehh = ifok;
      close(ELIGINDV);
    end;

    ///Executes Data Repair utility
    ///Parameters:
    ///string drXml - path to the input XML file
    ///string drLanguage - UI language. Values can be "English", "French", "Russian", "Spanish"
    function RunDataRepair(string drXml, string drLanguage)
      set trace(on);
      if isAndroid then
        SystemApp dataRepairApp;
        dataRepairApp.Clear();
        dataRepairApp.SetArgument("xmlfile", drXml);
        dataRepairApp.setArgument("language", drLanguage);
        x = dataRepairApp.exec("com.dec.datarepair");
        if debug then
          trace( maketext("result =%d, drxml=%s drLanguage=%s",x,drxml,drLanguage) );
        endif;
      else
        fpath = utility + "\DataRepPc";
        TheCommand = fpath + "\DataRepairPc.exe Android.xml";
        ExecSystem( TheCommand, normal, wait );
      endif;
    end;

    { concatenates the interviewer's HOUSEHOLD data with data from other interviewers }
    function concathh()
      { concatenate HOUSEHOLDs from all interviewers sharing data but first delete files }
      // set interviewer hh file name
      string int_hh    = data + "\H" + xfilenum + ".DAT";
      string shared_hh = work + "\H" + xcluster + "????.DAT";
      fdel( work + "\ALLHH.DAT" );
      fdel( work + "\ALLHH.DAT.csidx" );
      fdel( work + "\ALLHH.DAT.sts" );
      { the HH interviewer file has to be removed as it may exist empty }
      if FileEmpty(int_hh) then
        FileDelete(int_hh);
      endif;
      { concatenate HH data files }
      { ANDROID need to check if all files for the fileconcat are present to avoid error messages }

      if FileExist(int_hh ) then
        FileConcat( CGHH80, work + "\ALLHH.DAT",                         { resulting file }
                    int_hh,             { file from interviewer }
                    shared_hh);       { files from other interviewers }
        { concatenate partials for all HOUSEHOLDs from all interviewers }
        if FileExist ( int_hh + ".sts" ) & !FileEmpty ( int_hh + ".sts" ) then
          FileConcat( work + "\ALLHH.DAT.sts",                     { result file }
                      data + "\H" + xfilenum + ".DAT.sts",         { file from interviewer }
                      work + "\H" + xcluster + "????.DAT.sts" );   { files from other interviewers }
        else
          FileConcat( work + "\ALLHH.DAT.sts",                     { result file }
                      work + "\H" + xcluster + "????.DAT.sts" );   { files from other interviewers }
        endif;
      elseif FileExist(shared_hh) then
        FileConcat( CGHH80, work + "\ALLHH.DAT",                         { resulting file }
                    shared_hh);       { files from other interviewers }
        { concatenate partials for all HOUSEHOLDs from all interviewers }
        FileConcat( work + "\ALLHH.DAT.sts",                     { result file }
                    work + "\H" + xcluster + "????.DAT.sts" );   { files from other interviewers }
      endif;
    end;

    { concatenates the interviewer's HOUSEHOLD and INDIVIDUAL notes taken in the cluster }
    function ConcatNotes()
      numeric fh, fi, fres;
      { concatenate HOUSEHOLDs from all interviewers sharing data but first delete files }
      fdel( work + "\ALLNOTES.DAT" );
      { concatenate HH data files }
      fh = FileExist(data + "\H" + xfilenum + ".DAT.CSNOT" );      { notes for HH interviews }
      fi = FileExist(data + "\I" + xfilenum + ".DAT.CSNOT" );      { notes for INDIVIDUAL interviews }
          recode fh :: fi -> fres;
              0 ::  0 -> 0;       
              1 ::  1 -> 1;
              1 ::    -> 2;
                ::    -> 3;
      endrecode;
          if fres = 0 then
            errmsg( 030 )
      elseif fres = 1 then    { notes in INDIVIDUAL interviews }
        FileConcat( work + "\ALLNOTES.DAT",                      { resulting file }
                  data + "\H" + xfilenum + ".DAT.CSNOT",         { notes in HOUSEHOLD interviews }
                  data + "\I" + xfilenum + ".DAT.CSNOT" );       { notes in INDIVIDUAL interviews }
      elseif fres = 2 then
        FileConcat( work + "\ALLNOTES.DAT",                      { resulting file }
                  data + "\H" + xfilenum + ".DAT.CSNOT" );       { notes in HOUSEHOLD interviews }
      elseif fres = 3 then
        FileConcat( work + "\ALLNOTES.DAT",                      { resulting file }
                  data + "\I" + xfilenum + ".DAT.CSNOT" );       { notes in HOUSEHOLD interviews }
      endif;      
    end;

    { use system default application to display HTML files }
    function HTML_Display( string thisfile )
     view( thisfile + ".html" );
    end;



    { generates the PIF file for the application used to display }
    { INDIVIDUALs available to be interviewed in a HOUSEHOLD     }
    function MapHHpff( type )
      { type   1-HOUSEHOLDs, 2-INDIVIDUAL }
      InitPff();

      FileWrite( piffile, "StartMode=ADD" );
      FileWrite( piffile, "ShowInApplicationListing=Never" );
      FileWrite( piffile, "Fullscreen=Yes" );
      FileWrite( piffile, "NoFileOpen=Yes" );

      { Files section }
      FileWrite( piffile, " " );
      FileWrite( piffile, "[Files]" );
      FileWrite( piffile, "Application=" + entry + "\" + AppName + ".ent" );
      FileWrite( piffile, "Listing="     + entry + "\" + AppName + ".lst" );

      { External Files section }
      FileWrite( piffile, " " );
      FileWrite( piffile, "[ExternalFiles]" );
      FileWrite( piffile, "CG" + "HH" + pcode + "=" + work + "\ALLHH.DAT" );
      FileWrite( piffile, ccode + "IN" + pcode + "=" + data + "\I" + xfilenum + ".DAT" );

      { Parameters section }
      FileWrite( piffile, " " );
      FileWrite( piffile, "[Parameters]" );
      FileWrite( piffile, "Language=" + GetLanguage() );
      { parameters passed are: HOUSEHOLD number, HOUSEHOLD or INDIVIDUAL questionnaire and interviewer sex }
      FileWrite( piffile, "Parameter=" + edit("9999",WNUMBER) + edit("9",type) + edit("9",IntSex) );
      FileWrite( piffile, "ViewListing=Never" );
      FileWrite( piffile, "ViewResults=No" );
      FileWrite( piffile, "OnExit=.\DCMenu.pff" );
      close( piffile );
    end;

    function maphh();
      concathh();
      AppName = "mapHH";
      mapHHpff( 1 );
      SaveSetting( "DCSession", "1" );
      SaveSetting( "HHNumber", edit("9999",WNUMBER) );
      runpffS();
    end;

  { calls repair program to modify: cluster, hh number, line number or delete cases }
  function FixIds()
    InitPff();
    FileWrite( piffile, "StartMode=ADD" );
    FileWrite( piffile, "Fullscreen=Yes" );
    FileWrite( piffile, "ShowInApplicationListing=Never" );
    FileWrite( piffile, "NoFileOpen=Yes" );

    { Files section }
    FileWrite( piffile, " " );
    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, "Application=" + superv + "\" + AppName + ".ent" );
    FileWrite( piffile,  "InputData=" + wrkref + "\snull.dat");    

    { External Files section }
    FileWrite( piffile, " " );
    FileWrite( piffile, "[ExternalFiles]" );  

    FileWrite( piffile, "[Parameters]" );
    { parameters are: cluster and HOUSEHOLD number (may include others for sub-samples) }
     
    FileWrite( piffile, "Parameter=" + xcluster + xintnum + strip( getlanguage() ) );
    FileWrite( piffile, "ViewListing=Never" );
    FileWrite( piffile, "ViewResults=No" );
    close( piffile );
  end;
  function QuizApp (addmode, savpart, change, tnum = 1);
      InitPff();
      if addmode then
        FileWrite( piffile, "StartMode=ADD;" + edit("999", tnum), xintnum);
        FileWrite( piffile, "Lock=Add" );
      else
        FileWrite( piffile, "Lock=Add" );
        if savpart = 1 then
          FileWrite( piffile, "StartMode=ADD;" + edit("999", tnum) + xintnum);
        else
          FileWrite( piffile, "StartMode=MODIFY;" +  edit("999", tnum) + xintnum);
        endif;
      endif;
      FileWrite( piffile, "ShowInApplicationListing=Never" );
      { Files section }
      FileWrite( piffile, " " );
      FileWrite( piffile, "[Files]" );
      FileWrite( piffile, "Application=" + entry + "\" + AppName + ".ent" );
      FileWrite( piffile, "InputData=" + data + "\Q" + xintnum + ".DAT" );
      FileWrite( piffile, "Listing="     + entry + "\" + AppName + ".lst" );

      { External Files section }
      FileWrite( piffile, " " );
      FileWrite( piffile, "[ExternalFiles]" );
      FileWrite( piffile, "QUIZDATA_DICT=" + ".\cnull.dat");

      FileWrite( piffile, "[Parameters]" );
      FileWrite( piffile, "Language=" + GetLanguage() );
      FileWrite( piffile, "Parameter=" + xintnum );
      FileWrite( piffile, "ViewListing=Never" );
      FileWrite( piffile, "ViewResults=No" );
      FileWrite( piffile, "OnExit=.\DCMenu.pff" );
      FileWrite( piffile, "Parameter=" + xintnum );
      FileWrite( piffile, "QuizFolder=", wrkref);
      close( piffile );
    end;
    { receiving updated quiz data from supervisor }
    function receivequiz()
      string fmask;
      // copy files from supervisor machine
      // since using pull command will only copy those changed
      if isAndroid | useCSBT then
        btserver = edit("9999", WSUPER);
      endif;
      if SyncConnect( Bluetooth, btserver ) then
        fmask = quizdata + "\QZD*.dat";
        SyncFile( GET, fmask, wrkref );
        SyncDisconnect();
      endif;
    end;

  {*****************************************************************}
  {********** functions to handle fieldworker qre in CAPI **********}
  {*****************************************************************}

  { reads the CSPro sts file to find out if a HOUSEHOLD or INDIVIDUAL has been partially saved }
  function partialFW( nintnum, string FileToCheck )
    numeric FoundPart = 0, zlen;
    string  PartialRecord, findadd, findmod;
    setfile( PartialFile, FileToCheck + ".sts" );
    findadd  = "Pos=ADD." + edit("9999", nintnum);
    findmod  = "Pos=MOD." + edit("9999", nintnum);
    zlen = length(findadd);
    while !FoundPart do
      if !FileRead( PartialFile, PartialRecord ) then
        FoundPart = 3
      elseif pos( strip(findadd), PartialRecord[1:zlen] ) then
        FoundPart = 1
      elseif pos( strip(findmod), PartialRecord[1:zlen] ) then
        FoundPart = 2
      endif;
    enddo;
    close( PartialFile );
    if FoundPart in 1,2 then
      partialFW = FoundPart;
    else
      partialFW = 0;
    endif;
  end;

  function FieldWkQuest( addmode, savpart, change)
    InitPff();
    string fwparms;

    if addmode then
      FileWrite( piffile, "StartMode=ADD;" + xintnum );
      FileWrite( piffile, "Lock=Add" );
    else
      FileWrite( piffile, "Lock=Add" );
      if savpart = 1 then
        FileWrite( piffile, "StartMode=ADD;" + xintnum );
      else
        FileWrite( piffile, "StartMode=MODIFY;" + xintnum );
      endif;
    endif;
    FileWrite( piffile, "ShowInApplicationListing=Never" );
    FileWrite( piffile, "Fullscreen=YES" );
    FileWrite( piffile, "NoFileOpen=NO" );
    FileWrite( piffile, "Interactive=OFF" );

    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, "Application=" + entry + "\" + AppName + ".ent" );
    FileWrite( piffile, "InputData=" + data + "\F" + xintnum + ".DAT" );
    FileWrite( piffile, "Listing="   + data + "\F" + xintnum + ".lst" );

    FileWrite( piffile, "[ExternalFiles]" );
    FileWrite( piffile, "OTHERS="   + data     + "\FO" + xintnum + ".DAT" );
    FileWrite( piffile, "INTERV="   + wrkref     + "\Interv.csdb");

    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "Language=" + GetLanguage() );
    { customize parameters for different types of data entry modes }
    fwparms[1:1] = edit( "9", change );    { to run modify mode }
    fwparms[2:1] = edit( "9", savpart );   { case saved partially }
    fwparms[3:4] = xintnum;   { interviewer code  }
    FileWrite( piffile, "Parameter=" + fwparms );
    FileWrite( piffile, "OnExit=.\DCMenu.pff" );
    close( piffile );
  end;

  function restore ();
    // !!! restore the interviewer tablet data from supervisor
    // !!! used only to put data on a replacement tablet 
    if isAndroid | useCSBT then
      btserver = edit("9999", WSUPER);
    endif;
    if SyncConnect( Bluetooth, btserver ) then
      // get the assignment file
      fname = work + "\S" + xcluster + ".csdb";
      FileDelete( fname );
      SyncFile( GET, fname, work );
      // get the data files for that interviewer
      fname = receive + "\?" + xcluster + xintnum + ".DAT"; // data files
      SyncFile( GET, fname, data );
      fname = receive + "\?" + xcluster + xintnum + ".DAT.sts"; // sts
      SyncFile( GET, fname, data );
      fname = receive + "\?" + xcluster + xintnum + ".cslog";// paradata
      SyncFile( GET, fname, data );
      errmsg("Files restored for interviewer %s ", xintnum);
      // now get any new upgrades 
      fname = upgrades + "/" + upgrname + "*.zip";
      SyncFile( GET, fname, upgrades );
      SyncDisconnect();
      ApplyUpgr();
      // remove any index files
      CleanIndex(data);
      CleanIndex(work);
    endif;        
  end;
  function CleanFiles (string tid);
    FileDelete(receive + "\" + "?" + tid + "*.*");
    FileDelete(data + "\" + "?" + tid + "*.*");
    FileDelete(temp + "\" + "?" + tid + "*.*");
    FileDelete(work + "\" + "?" + tid + "*.*");
    FileDelete(pictures + "\" + "?" + tid + "*.*");
  end;
  function remblanks (string infilename, ftype);
    // remove blank lines from a data file
    FILE inTxt;
    FILE outTxt;
    string fline;
    numeric recordpos;
    numeric lncount = 0;
    if ftype = 1 then
      recordpos = 9
    else
      recordpos = 11; 
    endif;
    setfile(inTxt, infilename, update);
    setfile(outTxt, infilename + ".txt", create);
    while FileRead(inTxt, fline) do 
      inc(lncount);
      trace("line=%d", lncount);
      trace("[%s]", fline);
      if length(strip( fline[1:3] )) & length(strip( fline[recordpos:3] ))  then
        FileWrite(outTxt, fline);
      endif;
    enddo;
    close(inTxt);
    close(outTxt);
    FileCopy(outTxt, inTxt);
    FileDelete(outTxt);
  end;
  function CheckProcess (string process);
     list string fileinput;
     fname = concat(PathName(Application), "process.txt");
     TheCommand = MakeText('cmd /c tasklist /FI "IMAGENAME eq %s" /FO CSV > %s', process, fname);
     ExecSystem( TheCommand, minimized, wait, nofocus );
     justone.open(fname, create);
     justone.read(fileinput);
     CheckProcess = fileinput.length() - 1;
     justone.close();
     FileDelete(fname);
  end;
PROC FL_MENU
  
PreProc
    if debug then
      // errmsg(  "WARNING: DEBUG MODE ENABLED!" );
      trace(on, ".\debug.apc", clear);
  //  trace(on);
      set trace;
    endif;
    isAndroid = (getos() = 20);                  { boolean for type of OS !! }
    CSPro  = PathName( CSPro );
    wrkprj = "..";                               { work project in tablet/laptop }
 // wrkpii = wrkprj + "\PII";                         { subdirecory to store data with PII }
    wrkpii = wrkprj + "\PII";                         {!!! pretest field practice!!!}
    { Operator ID }
    opid = "Anyone";                               { this could be an ID set on each machine }

    ccode = "CG"; { country code !! }
    pcode = "80"; { phase code !! }

    // check menu not already running
    if !isAndroid then
      if CheckProcess("CSEntry.exe") > 1 then
        errmsg("The CAPI menu or interview program is already running on your tablet. Check for the JFHPS icon on the task bar at the bottom of the screen and click on it");
        stop(-1);
      endif;
    endif;

    { set font for value sets }
    setfont( All, "Arial", 18, bold );

    { set up minimal user bar }
    userbase();
    userbar( show );
    { set the language at the start of the program, defaulting to English }
    setlanguage("FR");
    setvaluesets( "_" + getlanguage() );
    SameSession = tonumber(loadsetting("DCSession"));

    
    { set main directories }
    entry    = wrkprj + "/Entry";     { data entry programs }
    dicts    = wrkprj + "/Dicts";     { dictionaries }
    utility  = wrkprj + "/Utility";   { all utilities used by the system }
    upgrades = wrkprj + "/Upgrades";  { upgrades sent by supervisors are stored here }
    wrkref   = wrkpii + "/Ref";       { reference directory for clusters, sample and teams files  }
    data     = wrkpii + "/Data" ;     { where data is stored }
    images   = wrkprj + "/Images";     { images  }
    temp     = wrkpii + "/Temp" ;     { used for several purposes but specially to store temporary data }
    work     = wrkpii + "/Work" ;     { working area to store concatenated HOUSEHOLDs }
    receive  = wrkpii + "/Receive" ;     {receive folder on supervisor - just used to copy files }
    superv   = wrkprj + "/Superv";     { supervisor programs }
    pictures = wrkpii + "/Pictures";  { working area to store pictures taken by applications }
    quizdata = wrkprj + "/Quiz" ;     { data for quiz}
    quest    = wrkprj + "/Questionnaires" ;
    { set directories to transfer data using bluetooth }
    if isAndroid then
      btwork   = work + "/";          { last portion of directory where HH data will be transferred to other interviewers when sharing HOUSEHOLDs }
    else
      btwork   = "/Pii/Work/";          { last portion of directory where HH data will be transferred to other interviewers when sharing HOUSEHOLDs }
    endif;
    btsup    = "/Pii/Temp/";          { last portion of directory where all files will be transferred to supervisors }
    btsamp   = "/Pii/SampData/";      { last portion of directory where HH listing for sampling selection will be stored in supervisor machines }

    ChkDir( temp );    
    { check presence of mandatory directories }
    ChkDir( entry );
    ChkDir( work );    
    ChkDir( upgrades ); 
    ChkDir( wrkref );  
    ChkDir( data );  
    ChkDir( images );  
    ChkDir( pictures );
    // remove any unneeded pffs 
    // FileDelete(PathName(Application) + "*.pff");
    
    { set up backup folder }
    if isAndroid  then
      backup = wrkpii + "/CSPRO_BACKUP"; { !! }
    else
      backup = "E:\DATA";                              { drive and directory to backup data }
    endif;
    chkdir(backup);

    { file names for upgrades }
    upgrname = "upgdhs";              { upgrade namess coming from supervisor machine }
    
    { check for upgrades and apply !!! }
    ApplyUpgr();
    
    { get current system version to enable restart after receiving update from supervisor }
    sysver      = getver( wrkref + "/version.txt" );

    { initialize array of interviewers }
    do i = 1 while i <= 20
      interview(i) = 0;
      intername(i) = "";
    enddo;

  
  { folder list for checking duplicates }
  dirstocheck = data, work;
  
  { load cluster file name }
  clustfname = FileName(CLUSTERS);

  { clean index files in case indexes were out of date/corrupted !!! }
  { just do it once when menu started }
  if SameSession = 1 then
    { clean any files from old phases !!! }
    { do this with care !!! }
    // CleanFiles("8");
    // CleanFiles("9");
  endif;

PostProc
    {PostProc of level 0 }
    stop(1);

  
PROC MENU_LEVEL
  
PreProc
  //  set attributes( MENU_DICT ) assisted on;
  //  set attributes( MENU_DICT ) assisted off ( variable(title) );

    open( INTERV );
    do j = 1 while loadcase( INTERV )    { load list of interviewers into memory }
      intvwcode(j) = ICODE;
      intvwname(j) = INAME;
      intvwteam(j) = ITEAM;
      intvwsex (j) = ISEX;
      intvwrole(j) = IROLE;
    enddo;
    totintvw = j-1;
    close( INTERV );
    if SameSession then
      advance to WFINAL
    endif;

  
PROC WSUPER
  
onfocus
    fieldworkers.clear();
    m_fieldworkers.clear();
    f_fieldworkers.clear();
    do j = 1 while j <= totintvw
      if intvwrole(j) = 2 then            { supervisor }
        fieldworkers.add( intvwname(j), intvwcode(j) );
      endif;
    enddo;
    SetValueSet( $, fieldworkers );
    
    $ = tonumber( loadsetting("Supervisor") );
    
  
postproc
    SaveSetting( "Supervisor", edit("9999",$) );
    do j = 1 while j <= totintvw & intvwcode(j) <> $ enddo;
    if j <= totintvw then
      steam = intvwteam(j);
    endif;

    { get an array of interviewers that belong to the same team }
    j = 0;
    do i = 1 while i <= totintvw
      if intvwteam(i) = steam then
        j = j + 1;
        interview(j) = intvwcode(i);
        interrole(j) = intvwrole(i);
        intername(j) = intvwname(i);
        if intvwrole(i) = 2 then
          SupName = intvwname(i);     { get supervisor's name }
        endif;
      endif;
    enddo;

  
PROC WINTNUM
  
onfocus
    fieldworkers.clear();
    do j = 1 while j <= totintvw
      if intvwrole(j) in 1:3 & intvwteam(j) = steam then // include biomarker technicians since they will do hh interviews !!!
        fieldworkers.add( intvwname(j), intvwcode(j) );
        if intvwsex(j) = 1 then
          m_fieldworkers.add( intvwname(j), intvwcode(j) );
        else
          f_fieldworkers.add( intvwname(j), intvwcode(j) );
        endif;
      endif;
    enddo;
    SetValueSet( $, fieldworkers );
    
    $ = tonumber( loadsetting("Interviewer") );

  
postproc
    SaveSetting( "Interviewer", edit("9999",$) );
    do j = 1 while j <= totintvw & intvwcode(j) <> $ enddo;
    if j > totintvw then
      reenter
    else
      IntCode = intvwcode(j);
      IntName = intvwname(j);
      IntSex  = intvwsex(j);
      IntRole = intvwrole(j);
    endif;
    j = 0;
    do i = 1 while i <= totintvw
      if intvwteam(i) = steam  & intvwcode(i) <> $ then
        j = j + 1;
            TeamShare(j,1) = edit("9999",intvwcode(i));
            TeamShare(j,2) = intvwname(i);
          endif;
    enddo;        

    // check bluetooth id is set to the interviewer code
    // Note we are using the interviewer CODE for the bluetooth id
    if ( isAndroid | useCSBT ) & getbluetoothname() <> edit("9999",IntCode ) then
      if isAndroid then
        setbluetoothname(edit("9999", IntCode));
      else
        // in Windows need to restart app in admin mode
        // to do this we call batch file which in turn calls shortcut file with admin privileges to run dcmenu
        if SameSession = 9 then   // if returning into menu with admin privileges set bt name
          setbluetoothname(edit("9999", IntCode));
          SaveSetting( "DCSession", "1" );
          AppName = ".\DCMenu"; // then quit menu and restart with normal user level for security reasons
          runpffS();
        else
          SaveSetting( "DCSession", "9" );                    // save session flag for restart
          errmsg(014);
          TheCommand = MakeText('cmd /c start %s\dcmenu.lnk', PathName(Application));
          ExecSystem( TheCommand, minimized, wait );          
          stop(1);
        endif;
      endif;
    endif;

  
PROC WCLUSTER
  
preproc
    if special(visualvalue(WCLUSTER)) then 
      $ = tonumber( loadsetting("Cluster") );
      noinput;
    endif; 
    
  
postproc
  // check cluster number is correct
  if FileExist( clustfname ) then
    setFile(ClUSTERS, clustfname, update);
    if !loadcase( CLUSTERS, WCLUSTER ) then
      errmsg( 001, WCLUSTER );
      reenter;
    endif;
    close(CLUSTERS);
    SaveSetting( "Cluster", edit("9999",$) );
  else
    errmsg( 007 );
    stop(-1);
  endif;
    
  {  errmsg( "Province=%s, Region=%s, District=%s, Commune=%s, ZD=%s", strip(YPROVINN), strip(YREGIONN), strip(YDISTRICTN), strip(YCOMUNEN), strip(YENUMERN) );}
    WURBRUR    = GetValueLabel( YURBRUR );
    WREGIONN   = YREGIONN;
    WSTATEN    = YSTATEN;
    WDISTRICTN = YDISTRICTN;
    WCITYN     = YCITYN;
    setalready = 0;
    xcluster = edit( "9999", $ );                              { cluster number }
    xintnum  = edit( "9999", WINTNUM );                        { Interviewer }
    xsuperv  = edit( "9999", WSUPER );                         { Supervisor }
    xteam    = edit( "99", steam  );                         { team }
    xparaux  = xintnum + xsuperv + "0" + "0000";
    xparamet = xparaux;
    { xparamet postions as received by the data collection applications }
    {  1:4   - interviewer number               }
    {  5:4   - supervisor number                }
    {  9:1   - central office and supervisors   }
    { 10:1   - revisit                          }
    { 11:1   - modify completed                 }
    { 12:1   - if case has been saved partially }
    { 13:1   - enter biomarker questionnaire    }
    { 14:4   - HOUSEHOLD number                 }
    { 18:2   - woman's line number              }
    xfilenum = xcluster + xintnum;       { Number corresponding to data file names }
  
PROC WFINAL
  
onfocus
    WNUMBER  = notappl;
    WADDRESS = " ";
    WCORRECT = notappl;
    if SameSession = 2 then // re-entering after a data entry session so do the backup here !!
      backupf();
      if IntCode = WSUPER then       { transfer within supervisor machine }
        transuper();
      endif;
    endif;
    heading = maketext("Ver[%s]", getver( wrkref + "/version.txt" ));
    if debug then
      heading = heading + " debug mode enabled !!"
    endif;

   codes.clear();
   { 1} codes.add("1 Menu des questionnaires Ménages",01);
   { 2} codes.add("2 Afficher les individus/biomarqueurs éligibles",02);
   { 3} codes.add("3 Entrer les données des biomarqueurs",03);
   { 4} codes.add("4 Menu des individus éligibles",04);
   { 5} codes.add("4A Delegation/sharing menu            ",5);
   { 6} codes.add("5 Afficher la liste des questionnaires de la grappe",06);
   { 7} codes.add("6 Afficher les notes sur la grappe",07);
   { 8} codes.add("[[ 7 Transfert de données/autres utilitaires ]]",08);
   {10} codes.add("10 Questionnaires Pratique",10);
   {11} codes.add("C Changer de numéro de grappe",11);
   {12} codes.add("E Quitter le système", 12);
  setvalueset($, codes);
   
  
postproc
    
    if loadsetting("DCSession") = "4" then
      skip to WINDIV
    endif;
    action = $;
    { instructions to complete executions of menu options }
    if action = 12 then
      SaveSetting( "DCSession", "1" );
      stop(1)
    endif;
    { change cluster number }
    if !action then
      reenter;
    elseif action = 11 then
      reenter WCLUSTER

    { all options to deal with HOUSEHOLDs manipulation and where women may be found }
    elseif action in 1:4 then
      if action = 4 & IntRole = 3 then //!!! prevent biomarker technicians from doing INDIVIDUAL interviews
        errmsg(103);
        reenter;
      else
        if !setalready & !SetAssignFile() then
          reenter;
        else
          setalready = 1;
        endif;
        { get a HOUSEHOLD }
        concathh();
        if action = 4 then
          if FindDups( dirstocheck , xcluster, 1) then
            errmsg("Duplicate HOUSEHOLD cases detected in data. The system will attempt to continue but you may find that not all HOUSEHOLDs are available. You should remove the duplicate cases as soon as possible");
          endif;
          WrkElig( 1, WNUMBER, IntSex ); 
        else
            WrkElig( 3, WNUMBER, IntSex ); 
        endif;
        if getonehh( action ) then
          advance to WCORRECT;
        endif;
      endif;

    { sharing households/delegation  }
    elseif action = 5 then
        
        option  = accept( "Menu de la délégation",
                  {  1} "Déléguer des indidivuels à un autre enquêteur(trice)",
                  {  2} "Transférer des délégations à un autre enquêteur(trice)",
                  {  3} "Recevoir des délégations d'un autre enquêteur(trice)");

       if option = 1 then
         concathh();
         if !FindDups( dirstocheck , xcluster, 1) then
          WrkElig( 1 );
          fill_caselist(1);
          numeric idx = showarray(heading, caselist, title ( tr("HH"), tr("Name"), tr("Int."), tr("Status") , tr("Male/LS"))  );
          x  = tonumber( caselist(idx,1) );
          WrkElig( 2, x, IntSex );
          fill_caselist(5);
          while 1 do
            idx = showarray(tr("Individuals to delegate"), caselist, title ( tr("Head"), tr("Number"), tr("Line"), tr("Name") , tr("Type") , tr("Status"), tr("Delegated")) );
            if idx then
              if caselist(idx,5) = "Homme"  then
                caselist(idx,7) = edit("9999", m_fieldworkers.show() );
              else
                caselist(idx,7) = edit("9999", f_fieldworkers.show() );
              endif;
            else
              break;
            endif;
          enddo;
          // now set the QHEDELEG flags in the household data
          setfile(CGHH80, data + "\H" + xfilenum + ".DAT", update);
          do idx = 1 until idx > caselist.length(1);
            numeric wdeleg = tonumber( caselist(idx,7) );
            if wdeleg then
              QHCLUST = WCLUSTER;
              QHNUMBER = tonumber(caselist(idx,2));
              numeric wdline  = tonumber( caselist(idx,3) );
              if loadcase(CGHH80, QHCLUST, QHNUMBER) then
                if QHDELEG(wdline) <> wdeleg then
                  QHDELEG(wdline) = wdeleg;
                  writecase(CGHH80);
                endif;
              endif;
            endif;
          enddo;
          close(CGHH80);
         endif;
      { transfer HOUSEHOLD data to another interviewer }
      elseif option = 2 then
        sendhhdat();
      { receive HOUSEHOLD data from another interviewer }
      elseif option = 3 then
        receivehh();
       endif;

    { lists interviewer's notes in cluster }
    elseif action = 7 then
      ConcatNotes();
      AppName = "LISTNOTES";
      ListNotes();
      runpffS();

    { lists questionnaires collected by interviewer }
    elseif action = 6 then
      AppName = "LSTQUEST";
      lstquest();
      runpffS();

    { menu to transfer/share and fix data and to obtain updates }
    elseif action = 8 then
        heading = "Transfer des données et outils. Grappe: " + xcluster + " Enq. " + edit("9999", WINTNUM);
        option  = accept( heading,
                  {  1} "1 Synchroniser avec superviseur/contrôleur",
                  {  2} "6 Modifier les IDs/Supprimer des questionnaires",
                  {  3} "7 [[Autres options]]",
                  {  4} "X Retourner au menu principal" );

      { return to main menu }
      if option = 4 then
        reenter;
      elseif option = 1 then
        { sync with supervisor }
        sync_sup();
        // check if update received and if so restart the menu !!
        if getver( wrkref + "/version.txt" ) <> sysver then
          errmsg(091);
          AppName = "DCMENU";
          runpffS();
        endif;
      elseif option = 3 then
        { fix identifiers (cluster, HOUSEHOLD, interviewers) or delete women  }
        RunDataRepair( maketext("csentry:%s/Android.xml", path.getrelativepath(Pathname(CSentry), entry)), "French" );
      elseif option = 4 then
        heading = "Autres options. Grappe: " + xcluster + " Enq. " + edit("9999", WINTNUM);
        numeric suboption  = accept( heading,
                  {1} "1 Corriger code enquêteur/Résultat dans un ménage",
                  {2} "2 Récupérer les données de restauration de la tablette du superviseur ",
                  {3} "3 Diviser un MÉNAGE ",
                  {4} "4 Effacer les données des ménages partagés ",
                  {5} "5 Réinitialiser les fichiers d'index ",
                  {6} "X Retourner au menu principal" );


        if suboption = 6 then
          reenter;
        { fix the result of a HOUSEHOLD assigned to interviewer }
        elseif suboption = 1 then
          if setalready | SetAssignFile() then
            AppName = "FIxResult";
            if selcase( HHFORINT, "") include( VNUMBER, VNAME, VINTCODE, VRESULT )  where VINTCODE <> notappl then
              FIxResult();
              close( HHFORINT );
              SaveSetting( "DCSession", "1" );
              runpffS();
            endif;
          endif;
        // restore data from supervisor tablet
        elseif suboption = 2 then
          restore();
        // split household
        elseif suboption = 3 then
          getonehh(5);
          // clear shared data from work folder
          // used to fix issues with duplicated cases
        elseif suboption = 4 then 
          x = errmsg("Are you sure you wish to remove shared HOUSEHOLD data from the interviewer tablet ?\n To access INDIVIDUAL interviews from already shared HOUSEHOLDs you will need to receive shared data again ") select ("No", continue, "Yes, remove", continue);
          if x = 2 then
            FileDelete(work + "\H" + xcluster + "????.DAT");
            FileDelete(work + "\H" + xcluster + "????.DAT.sts");
            FileDelete(work + "\H" + xcluster + "????.DAT.csidx");
            errmsg("Shared data removed");
          endif;
        // clear indexes and allhh* files 
        elseif suboption = 5 then 
          fname = data + "\H" + xfilenum + ".DAT";
          if !FileEXist(fname) | FileEmpty(fname) then
            errmsg("File for interviewer %04d not present on tablet", intcode);
          else
            x = errmsg("PLease confirm you wish to clean interviewer files for interviewer %04d", intcode) 
            select ("Yes, clean", continue, "No, do not clean", continue);
            if x = 1 then
              fixdata(fname, 1);
              errmsg("Files for interviewer %04d cleaned", intcode);
            endif;
          endif;
          FileDelete(work + "\ALLHH.*");
          FileDelete(work + "\ALLHH.*.*");
          CleanIndex(work);
          CleanIndex(data);
        elseif suboption = 6 then 
      // clean data file by removing corrupted lines with blanks in id and record fields
          fname = data + "\H" + xfilenum + ".DAT";
          errmsg("fname=%s", fname);
          if !FileEXist(fname) | FileEmpty(fname) then
            errmsg("File %s not present on tablet", fname);
          else
            x = errmsg("PLease confirm you wish to clean files") 
            select ("Yes, clean", continue, "No, do not clean", continue);
            if x = 1 then
              backupf(); // back up file before removing blanks
              remblanks(fname, 1);
              errmsg("Files for interviewer %04d cleaned", intcode);
            endif;
          endif;
        endif;
  endif;
elseif action = 10 then // view practice questionnaires
    ShowQrePDf(quest);
    reenter;
endif;

    reenter;

  
PROC WNUMBER
  
preproc
    $ = ZNUMBER;

  
PROC WADDRESS
  
preproc
    if length( strip(ZNAME) ) & length( strip(ZADDRESS) ) then
      $ = strip(ZNAME) + " - " + strip(ZADDRESS);
    elseif length( strip(ZNAME) ) then
      $ = ZNAME;
    else
      $ = ZADDRESS;
    endif;

  
PROC WCORRECT
  
preproc
    $ = 1;
    noinput;

  
postproc
    if $ <> 1 then
      reenter WFINAL;
    endif;
    xparamet = xparaux  + edit("9999",ZNUMBER);
    xcase    = xcluster + edit("9999",ZNUMBER);
    { start data collection for a HOUSEHOLD }
    if action = 1 then
      partial  = partialcs( 1, WCLUSTER, WNUMBER, 0, data + "\H" + xfilenum + ".DAT" );
      AppName = "COLLECTHH";
      recode partial :: ZRESULT -> x   ;
                    0:: 0       -> csrun( 1, 1, 0, 0, 0, 0 );{ NEW HH: add, hh, !partial, !revisit, !change, !heigth/weight }
                 >= 1:: 0,2:9   -> csrun( 0, 1, 1, 1, 0, 0 ); { PARTIAL SAVE, incomplete : modify, hh, partial, revisit, !change, !heigth/weight }
                 >= 1:: 1       -> csrun( 0, 1, partial, 1, 0, 0 ); { PARTIAL, result=1: modify, hh, partial, revisit, !change, !height/weight }
                    0:: 1       -> csrun( 0, 1, 0, 0, 1, 0 ); { MODIFY COMPLETE : modify, hh, !partial, !revisit, change, !heigth/weight }
                    0:: 2:9     -> csrun( 0, 1, 1, 1, 0, 0 ); { PARTIAL SAVE, incomplete : modify, hh, partial, revisit, !change, !heigth/weight }
                     ::         -> 9; 
      endrecode; 
      if x = 9 then
        errmsg("Partial=%d, Zresult=%d,use option 7 Data Exchange-> 7 Fix result in a HOUSEHOLD to resolve problem",partial,zresult);
      endif;
    elseif action = 2 then
      AppName = "LISTELIG";
      ListElig();
      runpffS();
    elseif action = 3 then  { enter height and weight }
      if ZRESULT <> 1 then
        errmsg( 012, ZRESULT );
        reenter WFINAL;
      endif;
      { add, hh, !partial, !revisit, !change, height/weight }
      AppName = "COLLECTHH";
      csrun( 1, 1, 0, 0, 0, 1 );
    { HOUSEHOLD where eligible INDIVIDUALs will be selected }
    elseif action = 4 then
      if ZOWNER = IntCode & ZRESULT <> 1 then
        errmsg( 080, ZRESULT );
        reenter WFINAL;
      endif;
      advance to WFINAL2;
    endif;
    reenter WFINAL;

  
PROC WFINAL2
  
preproc
    WINDIV    = notappl;
    WCORRECT2 = notappl;
    WNAME     = "";
    if FindDups( dirstocheck, xcluster, 1  ) then
      reenter WFINAL;
    else
      concathh();
      WrkElig( 2, WNUMBER, IntSex );           { generates file with HH from all interviewers and others }
      noinput;
    endif;

  
PROC WINDIV
  
preproc
    SetEligFile(0);
    fill_caselist(3);
    SaveSetting( "DCSession", "1" );
      ifok = showarray(tr( "Select INDIVIDUAL for interview" ), caselist, 
      title ( tr("HH"), tr("Line"),tr("Name"), tr("Interviewer"),tr("Ques."), tr("Status") )  );
      if ifok then
       SetEligFile(0);
       ZNUMBER = tonumber( caselist(ifok,1) );
       ZLINE   = tonumber( caselist(ifok,2) );
       x = loadcase(ELIGINDV, WCLUSTER, ZNUMBER, ZLINE );
       $ = ZLINE;
       close(ELIGINDV);
    else
      errmsg( 020 );
      reenter WFINAL
    endif;
    WNAME = ZNAME;

  
PROC WCORRECT2
  
preproc
    $ = 1;
    noinput;

  
postproc
    if $ <> 1 then
      reenter WFINAL;
    endif;
    xparamet = xparaux  + edit("9999",ZNUMBER) + edit("99",WINDIV);
    xcase    = xcluster + edit("9999",ZNUMBER) + edit("99",WINDIV);
    AppName = "CollectIN";
    SaveSetting( "DCSession", "2" );

    partial = partialcs( 2, WCLUSTER, WNUMBER, WINDIV, strip(data)+"\I"+strip(xfilenum)+".dat" );
    recode partial :: ZSTATUSC-> x   ;
                  0:: 0       -> csrun( 1, 2, 0, 0, 0, 0 ); { NEW : add, wm, !partial, !revisit, !change, !heigth/weight }
                  0:: 2       -> csrun( 0, 2, 1, 1, 0, 0 ); { modify, INDIVIDUAL, !partial, revisit, !change, !height/weight }
               >= 1:: 2       -> csrun( 0, 2, 1, 1, 0, 0 ); { PARTIAL : modify, wm, !partial, revisit, !change, !heigth/weight }
                   :: 1       -> csrun( 0, 2, 0, 0, 1, 0 ); { MODIFY CMPLETE : modify, wm, !partial, !revisit, change, !heigth/weight }
                   :: 3       -> csrun( 0, 2, partial, 1, 0, 0 ); { modify, INDIVIDUAL, partial, revisit, !change, !height/weight }
                  1:: 0       -> csrun( 1, 2, 0, 0, 0, 0 ); { modify, INDIVIDUAL, partial, revisit, !change, !height/weight }
                   ::         -> 9;
    endrecode; 
    if x = 9 then
      errmsg("Partial=%d, result=%d,use option 7 Data Exchange-> 7 Fix result in a HOUSEHOLD to resolve problem",partial,ZSTATUSC);
    endif;
